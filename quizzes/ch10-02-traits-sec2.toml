[[questions]]
id = "a2a1546b-27bf-47d2-a1bc-86d777573f40"
type = "Tracing"
prompt.program = """
fn clonable<T: Clone>(t: T) -> impl Clone { t }

fn main() {
  let s = String::from("hello");
  let s2 = clonable(s);
  println!("{}", s2.clone());
}
"""
answer.doesCompile = false
answer.lineNumber = 6
context = """
Because `clonable` returns `impl Clone`, then we only know that `s2` is *some* type that implements `Clone`, 
not that it is a `String` (or any type that implements `Display`). Therefore we cannot print `s2`.
"""


[[questions]]
id = "8b35f91c-ced2-4b8f-bf1c-90550f2b744b"
type = "MultipleChoice"
prompt.prompt = """
What is the smallest set of trait bounds on `T` needed to make this function type-check?
```
fn f<T: /* ??? */>(t: &T) {
  let t2 = t.clone();
  println!("{t2}");
}
```
"""
answer.answer = "`Clone + Display`"
prompt.distractors = [ "(no bounds)", "`Clone`", "`Clone + Display + Debug`" ]
context = """
Because `clone` is called and the `{}` display brackets are used in a formatter, then `T` must be `Clone` and `Display`.
"""
