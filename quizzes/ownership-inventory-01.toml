[[questions]]
type = "MultipleChoice"
prompt.prompt = """
*Function 1*

The function below is rejected by the compiler. Which statement best describes why?

```
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}
```
"""
prompt.choices = [
  "All variables must be initialized before they are used. However, `default` is used before it is initialized.",
  "Both branches of an if-expression must return a value of the same type. However, `user_str` and `&default` have different types.",
  "The returned value must live as long as `user_str`. However, `default` has a shorter lifetime than `user_str`.",
  "A function cannot return a reference. However, `make_separator` returns a value of type `&str`."
]
answer.answer = 2
context = """
The type signature `(user_str: &str) -> &str` requires that the input reference (`user_str`) and the output reference (either `user_str` or `&default`) have the same lifetime. `user_str` of course has the same lifetime as itself. But `default` is created inside `make_separator`, and the reference `&default` does not own `default`, so the lifetime of `default` is the scope of `make_separator`. Therefore `default` does not live as long as `user_str`, and the borrow checker will raise an error.
"""

[[questions]]
type = "MultipleChoice"
prompt.prompt = """
*Function 1*

Assume the function below was *not* rejected by the compiler. Which program using this function would violate memory safety if executed?

```
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}
```
"""
prompt.choices = [
"""```
let s = "";
let s2 = make_separator(s);
println!("{}", s2);
```""",

"""```
let mut s = "foo";
let s2 = make_separator(s);
s = "bar";
println!("{} {}", s, s2);
```""",

"""```
let s = "";
make_separator(s);
println!("{}", s);
```""",
"""```
let s = make_separator(make_separator("foo"));
println!("{}", s);
```"""
]
answer.answer = 0
context = """
When `default` goes out of scope at the end of `make_separator`, its data will be deallocated. Therefore to cause a memory safety violation, the program must (1) pass `""` as input to `make_separator` to get the default as output, and (2) read the output of `make_separator` e.g. via `println`. This causes a read of deallocated memory.
"""

[[questions]]
type = "MultipleChoice"
prompt.prompt = """
*Function 1*

The function below is rejected by the compiler. Which change to this function fixes the compiler error while best preserving the intention of the function?

```
// Makes a string to separate lines of text, 
// returning a default if the provided string is blank
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    &default
  } else {
    user_str
  }
}
```

Note: only code that is highlighted is different from the initial function.
"""
prompt.choices = [
"""```
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    `[default]`
  } else {
    user_str
  }
}
```""",

"""```
fn make_separator(user_str: &str) -> `[String]` {
  if user_str == "" {
    `["=".repeat(10)]`    
  } else {
    `[user_str.to_owned()]`
  }
}
```""",

"""```
fn make_separator(user_str: &str) -> &str {
  `[let default = "=".repeat(10);]`
  if user_str == "" {
    &default
  } else {
    user_str
  }
}
```""",

"""```
fn make_separator(user_str: &str) -> &str {
  if user_str == "" {
    let default = "=".repeat(10);
    `[return &default;]`
  } else {
    `[return user_str;]`
  }
}
```"""
]
answer.answer = 1
context = """
Rust will never allow you to return a pointer to a stack-allocated value. Therefore the simplest solution is to instead return an owned `String` instead of a reference `&str`. The downside to this approach is that it requires a heap allocation when calling `user_str.to_owned()`.

A more optimal approach would use a construct we have not discussed, the [`Cow`](https://doc.rust-lang.org/std/borrow/enum.Cow.html) smart pointer. `Cow` allows you to handle a case where data could come from either a reference or an owned value. For example:

```
use std::borrow::Cow;
fn make_separator(user_str: &str) -> Cow<'_, str> {
  if user_str == "" {
    let default = "=".repeat(10);
    Cow::Owned(default)
  } else {
    Cow::Borrowed(user_str)
  }
}
```
"""
